// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: api/book/v1/book.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "api.book.v1";

/** Possible formats in which the book may be published. */
export enum Format {
  /** FORMAT_UNSPECIFIED - Default value. This value is unused. */
  FORMAT_UNSPECIFIED = 0,
  /** FORMAT_HARDBACK - The printed format, in hardback. */
  FORMAT_HARDBACK = 1,
  /** FORMAT_PAPERBACK - The printed format, in paperback. */
  FORMAT_PAPERBACK = 2,
  /** FORMAT_EBOOK - An electronic book format. */
  FORMAT_EBOOK = 3,
  /** FORMAT_AUDIOBOOK - An audio recording. */
  FORMAT_AUDIOBOOK = 4,
}

export interface GetBookRequest {
  /**
   * The name of the book to retrieve.
   * Format: publishers/{publisher}/books/{book}
   */
  name: string;
}

/** A representation of a book. */
export interface Book {
  /**
   * The resource name of the book.
   * Format: publishers/{publisher}/books/{book}
   */
  name: string;
  /** The title of the book. */
  title: string;
  /** The author of the book. */
  author: string;
  /** The format of the book. */
  format: Format;
  /** ISBN number */
  isbn: string;
  /** Number of pages */
  pages: number;
  /** Publication year */
  publicationYear: number;
  /** Book description */
  description: string;
}

/** Response for GetBook */
export interface GetBookResponse {
  /** The format of the book. */
  format: Format;
  /** The name of the book */
  name: string;
}

/** Request message for ListBooks */
export interface ListBooksRequest {
  /**
   * The parent publisher resource name.
   * Format: publishers/{publisher}
   */
  parent: string;
  /** The maximum number of books to return. */
  pageSize: number;
  /** The page token for pagination. */
  pageToken: string;
  /** Optional filter by format */
  format: Format;
}

/** Response message for ListBooks */
export interface ListBooksResponse {
  /** The list of books. */
  books: Book[];
  /** Token for the next page of results. */
  nextPageToken: string;
  /** Total count of books */
  totalCount: number;
}

/** Request message for CreateBook */
export interface CreateBookRequest {
  /**
   * The parent publisher resource name.
   * Format: publishers/{publisher}
   */
  parent: string;
  /** The book to create. */
  book: Book | undefined;
}

/** Request message for UpdateBook */
export interface UpdateBookRequest {
  /** The book to update. */
  book:
    | Book
    | undefined;
  /**
   * The list of fields to update.
   * Use "*" to update all fields.
   */
  updateMask: string;
}

/** Request message for DeleteBook */
export interface DeleteBookRequest {
  /**
   * The name of the book to delete.
   * Format: publishers/{publisher}/books/{book}
   */
  name: string;
}

/** Response message for DeleteBook */
export interface DeleteBookResponse {
  /** Success indicator */
  success: boolean;
  /** Optional message */
  message: string;
}

/** Request message for SearchBooks */
export interface SearchBooksRequest {
  /**
   * The parent publisher resource name.
   * Format: publishers/{publisher}
   */
  parent: string;
  /** Search query (searches title and author) */
  query: string;
  /** Maximum number of results */
  pageSize: number;
  /** Page token for pagination */
  pageToken: string;
  /** Optional filter by format */
  format: Format;
}

/** Response message for SearchBooks */
export interface SearchBooksResponse {
  /** The list of books matching the search. */
  books: Book[];
  /** Token for the next page of results. */
  nextPageToken: string;
  /** Total count of matching books */
  totalCount: number;
}

function createBaseGetBookRequest(): GetBookRequest {
  return { name: "" };
}

export const GetBookRequest = {
  encode(message: GetBookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBookRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseBook(): Book {
  return { name: "", title: "", author: "", format: 0, isbn: "", pages: 0, publicationYear: 0, description: "" };
}

export const Book = {
  encode(message: Book, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.author !== "") {
      writer.uint32(26).string(message.author);
    }
    if (message.format !== 0) {
      writer.uint32(32).int32(message.format);
    }
    if (message.isbn !== "") {
      writer.uint32(42).string(message.isbn);
    }
    if (message.pages !== 0) {
      writer.uint32(48).int32(message.pages);
    }
    if (message.publicationYear !== 0) {
      writer.uint32(56).int32(message.publicationYear);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Book {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.author = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.isbn = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.pages = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.publicationYear = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetBookResponse(): GetBookResponse {
  return { format: 0, name: "" };
}

export const GetBookResponse = {
  encode(message: GetBookResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.format !== 0) {
      writer.uint32(8).int32(message.format);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBookResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseListBooksRequest(): ListBooksRequest {
  return { parent: "", pageSize: 0, pageToken: "", format: 0 };
}

export const ListBooksRequest = {
  encode(message: ListBooksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.format !== 0) {
      writer.uint32(32).int32(message.format);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBooksRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBooksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseListBooksResponse(): ListBooksResponse {
  return { books: [], nextPageToken: "", totalCount: 0 };
}

export const ListBooksResponse = {
  encode(message: ListBooksResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.books) {
      Book.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalCount !== 0) {
      writer.uint32(24).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBooksResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBooksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.books.push(Book.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCreateBookRequest(): CreateBookRequest {
  return { parent: "", book: undefined };
}

export const CreateBookRequest = {
  encode(message: CreateBookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.book !== undefined) {
      Book.encode(message.book, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateBookRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.book = Book.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateBookRequest(): UpdateBookRequest {
  return { book: undefined, updateMask: "" };
}

export const UpdateBookRequest = {
  encode(message: UpdateBookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.book !== undefined) {
      Book.encode(message.book, writer.uint32(10).fork()).ldelim();
    }
    if (message.updateMask !== "") {
      writer.uint32(18).string(message.updateMask);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateBookRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.book = Book.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteBookRequest(): DeleteBookRequest {
  return { name: "" };
}

export const DeleteBookRequest = {
  encode(message: DeleteBookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteBookRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteBookResponse(): DeleteBookResponse {
  return { success: false, message: "" };
}

export const DeleteBookResponse = {
  encode(message: DeleteBookResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteBookResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseSearchBooksRequest(): SearchBooksRequest {
  return { parent: "", query: "", pageSize: 0, pageToken: "", format: 0 };
}

export const SearchBooksRequest = {
  encode(message: SearchBooksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.format !== 0) {
      writer.uint32(40).int32(message.format);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchBooksRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchBooksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseSearchBooksResponse(): SearchBooksResponse {
  return { books: [], nextPageToken: "", totalCount: 0 };
}

export const SearchBooksResponse = {
  encode(message: SearchBooksResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.books) {
      Book.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalCount !== 0) {
      writer.uint32(24).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchBooksResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchBooksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.books.push(Book.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

export type BookServiceService = typeof BookServiceService;
export const BookServiceService = {
  /** Get a single book by name */
  getBook: {
    path: "/api.book.v1.BookService/GetBook",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBookRequest) => Buffer.from(GetBookRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetBookRequest.decode(value),
    responseSerialize: (value: GetBookResponse) => Buffer.from(GetBookResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetBookResponse.decode(value),
  },
  /** List all books for a publisher with pagination */
  listBooks: {
    path: "/api.book.v1.BookService/ListBooks",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListBooksRequest) => Buffer.from(ListBooksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListBooksRequest.decode(value),
    responseSerialize: (value: ListBooksResponse) => Buffer.from(ListBooksResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListBooksResponse.decode(value),
  },
  /** Create a new book */
  createBook: {
    path: "/api.book.v1.BookService/CreateBook",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateBookRequest) => Buffer.from(CreateBookRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateBookRequest.decode(value),
    responseSerialize: (value: Book) => Buffer.from(Book.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Book.decode(value),
  },
  /** Update an existing book */
  updateBook: {
    path: "/api.book.v1.BookService/UpdateBook",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateBookRequest) => Buffer.from(UpdateBookRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateBookRequest.decode(value),
    responseSerialize: (value: Book) => Buffer.from(Book.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Book.decode(value),
  },
  /** Delete a book */
  deleteBook: {
    path: "/api.book.v1.BookService/DeleteBook",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteBookRequest) => Buffer.from(DeleteBookRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteBookRequest.decode(value),
    responseSerialize: (value: DeleteBookResponse) => Buffer.from(DeleteBookResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteBookResponse.decode(value),
  },
  /** Search books by title or author */
  searchBooks: {
    path: "/api.book.v1.BookService/SearchBooks",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SearchBooksRequest) => Buffer.from(SearchBooksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SearchBooksRequest.decode(value),
    responseSerialize: (value: SearchBooksResponse) => Buffer.from(SearchBooksResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SearchBooksResponse.decode(value),
  },
} as const;

export interface BookServiceServer extends UntypedServiceImplementation {
  /** Get a single book by name */
  getBook: handleUnaryCall<GetBookRequest, GetBookResponse>;
  /** List all books for a publisher with pagination */
  listBooks: handleUnaryCall<ListBooksRequest, ListBooksResponse>;
  /** Create a new book */
  createBook: handleUnaryCall<CreateBookRequest, Book>;
  /** Update an existing book */
  updateBook: handleUnaryCall<UpdateBookRequest, Book>;
  /** Delete a book */
  deleteBook: handleUnaryCall<DeleteBookRequest, DeleteBookResponse>;
  /** Search books by title or author */
  searchBooks: handleUnaryCall<SearchBooksRequest, SearchBooksResponse>;
}

export interface BookServiceClient extends Client {
  /** Get a single book by name */
  getBook(
    request: GetBookRequest,
    callback: (error: ServiceError | null, response: GetBookResponse) => void,
  ): ClientUnaryCall;
  getBook(
    request: GetBookRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBookResponse) => void,
  ): ClientUnaryCall;
  getBook(
    request: GetBookRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBookResponse) => void,
  ): ClientUnaryCall;
  /** List all books for a publisher with pagination */
  listBooks(
    request: ListBooksRequest,
    callback: (error: ServiceError | null, response: ListBooksResponse) => void,
  ): ClientUnaryCall;
  listBooks(
    request: ListBooksRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListBooksResponse) => void,
  ): ClientUnaryCall;
  listBooks(
    request: ListBooksRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListBooksResponse) => void,
  ): ClientUnaryCall;
  /** Create a new book */
  createBook(
    request: CreateBookRequest,
    callback: (error: ServiceError | null, response: Book) => void,
  ): ClientUnaryCall;
  createBook(
    request: CreateBookRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Book) => void,
  ): ClientUnaryCall;
  createBook(
    request: CreateBookRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Book) => void,
  ): ClientUnaryCall;
  /** Update an existing book */
  updateBook(
    request: UpdateBookRequest,
    callback: (error: ServiceError | null, response: Book) => void,
  ): ClientUnaryCall;
  updateBook(
    request: UpdateBookRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Book) => void,
  ): ClientUnaryCall;
  updateBook(
    request: UpdateBookRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Book) => void,
  ): ClientUnaryCall;
  /** Delete a book */
  deleteBook(
    request: DeleteBookRequest,
    callback: (error: ServiceError | null, response: DeleteBookResponse) => void,
  ): ClientUnaryCall;
  deleteBook(
    request: DeleteBookRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteBookResponse) => void,
  ): ClientUnaryCall;
  deleteBook(
    request: DeleteBookRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteBookResponse) => void,
  ): ClientUnaryCall;
  /** Search books by title or author */
  searchBooks(
    request: SearchBooksRequest,
    callback: (error: ServiceError | null, response: SearchBooksResponse) => void,
  ): ClientUnaryCall;
  searchBooks(
    request: SearchBooksRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SearchBooksResponse) => void,
  ): ClientUnaryCall;
  searchBooks(
    request: SearchBooksRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SearchBooksResponse) => void,
  ): ClientUnaryCall;
}

export const BookServiceClient = makeGenericClientConstructor(
  BookServiceService,
  "api.book.v1.BookService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): BookServiceClient;
  service: typeof BookServiceService;
  serviceName: string;
};
